**แนวคิด**

โจทย์ข้อนี้เป็นแนว Greedy Algorithm

เราจะนิยามตัวแปร $C_{i}$ เป็นคะแนนที่ได้จากการทำภารกิจที่ $i$ ดังนั้น $C_{i} = B_{i} - 2 * A_{i}$ (โจทย์ได้กำหนดไว้) 

หลังจากที่เราได้ค่า $C_{i}$ ตั้งแต่ภารกิจที่ $1$ ถึง $N$ แล้วเราจะทำการ Sort ค่า $C_{i}$ ทั้งหมดจากมากไปน้อย โดยจะสมมติว่าได้เป็น $C'_{i}$ ออกมาแล้วจะพิจารณาคะแนนรวมที่มากที่สุดหลังหักค่าปรับแล้วจาก $(\sum_{j=1}^{i} C'_{j}) - (N - i)^{2}$ โดยที่ $i = 1 ... n$ 

Time Complexity: $\mathcal{O}(N\log{}(N))$

#### 
**ทำไมถึงสามารถใช้วิธีนี้ได้**

จุดสังเกตคือ การเลือกภารกิจที่จะทำนั้นไม่ได้ส่งผลต่อการเปลี่ยนแปลงของค่าปรับ **ถ้าจำนวนภารกิจที่เราไม่ได้ทำนั้นเท่ากัน** หมายความว่าถ้าเราทำเลือกภารกิจจำนวน $P$ ภารกิจเราจะต้องเสียค่าปรับเท่ากับ $(N - P)^{2}$ เสมอ 

ดังนั้นแปลว่าถ้าเราให้ผลรวมของคะแนนที่มากที่สุดก่อนหักค่าปรับจากการทำภารกิจ $P$ ภารกิจคือ $S$ และคะแนนรวมก่อนหักค่าปรับของภารกิจ $P$ ภารกิจที่เลือกไม่เหมือนกับข้างต้นคือ $S'$

แสดงว่า $S' \leq S$ จะได้ว่า $S' - (N - P)^{2} \leq S - (N - P)^{2}$

ซึ่งถ้าเรา Sort $C_{i}$ จากมากไปน้อยแล้วเลือกตั้งแต่ตัวที่ $1$ ถึงตัวที่ $P$ จะการันตีว่าเราจะได้ผลรวมของคะแนนที่มากที่สุดก่อนหักค่าปรับจากการทำภารกิจ $P$ ภารกิจ

#### 
**โค้ดตัวอย่างในภาษา C++**

```cpp
#include <bits/stdc++.h>

using namespace std;
const long long INF = 1e18;

vector<long long> c;

int main() {
  int n;
  scanf("%d", &n);
  for (int i = 0; i < n; i++) {
    long long a, b;
    scanf("%lld %lld", &a, &b);
    c.push_back(b - 2 * a);
  }
  sort(c.begin(), c.end(), greater<long long>());
  long long ans = -INF, notdo = n, now_sum = 0;
  for (auto i : c) {
    now_sum += i;
    notdo--;
    ans = max(ans, now_sum - (notdo * notdo));
  }
  printf("%lld", ans);
}
```