ในข้อนี้เราเขียนระยะห่างระหว่าง access point $i$ และ access point $j$ ด้วย $d(i, j)$ ซึ่งเราจะนิยามให้ $d(i, j) = (x_i-x_j)^2 + (y_i-y_j)^2$

สมมติก่อนว่าเรารู้ค่า $P$ แล้ว ค่า $a[i][j]$ ซึ่งบอกว่า access point $i$ คุยกับ access point $j$ ได้ไหม ควรจะมีค่าเป็น $1$ ก็ต่อเมื่อ $d(i, j) \leq P^2$ เท่านั้น มิเช่นนั้นควรจะมีค่าเป็น $0$

หากเรานำค่า $a[i][j]$ **จริง**ทั้งหมดมาเรียงกันจากน้อยไปมากตามค่า $d(i, j)$ ที่เกี่ยวข้องกับมัน จะได้ลำดับใหม่คือ $S_1, S_2, S_3, ..., S_m$ ($m =$ จำนวนข้อมูล) เราจะได้ว่า จะมี index $k$ โดย $0 \leq k \leq m$ ที่ $S_i = 1$ สำหรับ $1 \leq i \leq k$ และ $S_i = 0$ สำหรับ $k< i \leq m$ กล่าวคือลำดับจะเป็นเลข $1$ ตลอดไปจนถึงจุด ๆ หนึ่ง แล้วเปลี่ยนเป็น $0$ ตลอดจนจบลำดับ (หรืออาจจะไม่มี $1$ เลยก็ได้)

ดังนั้นเพื่อที่จะหาคำตอบที่ดีที่สุด เราจะสร้างลำดับ $T$ โดยวิธีคล้ายกับการสร้างลำดับ $S$ ข้างต้น แต่เราจะใช้ค่า $a[i][j]$ **ที่โจทย์ให้มา**แทน จากนั้นเราจะไล่เทียบกับ $S$ ที่เป็นไปได้ทั้งหมดโดยการเปลี่ยนค่า $k$ ไปเรื่อย ๆ จาก $k=0$ ถึง $k=m$ (ซึ่ง $k$ คือจุดสุดท้ายที่ลำดับ $S$ มีค่าเป็น $1$) แล้วในแต่ละครั้งของการไล่ เราจะคำนวณหาจำนวนสมาชิกของ $T$ ที่ไม่เหมือน $S$ คำตอบของเราจะมีค่าเท่ากับค่าที่น้อยที่สุดของจำนวนที่สมาชิกที่ต่างกันในแต่ละครั้งของการไล่

แต่ข้อนี้มีข้อควรระวังคือ เราจะไม่สามารถใช้ $k$ บางค่าได้ เนื่องจากอาจจะมีกรณีที่ระยะทางมีค่าเท่ากัน ยกตัวอย่างเช่น ลำดับ $T$ ของเราอาจจะมีค่า $d(i, j)$ ที่สอดคล้องเท่ากับ $10, 25, 30, 30, 30, 45, 60$ สังเกตว่าถ้าเราให้ $k = 3$ จะได้ว่า $30 \leq P^2$ และ $30 > P^2$ ในเวลาเดียวกัน ซึ่งไม่สามารถเป็นไปได้ ดังนั้นเวลาไล่ค่า $k$ ให้เราข้าม index พวกนี้ไปเลย

ในการคำนวณหาจำนวนสมาชิกที่ต่าง ให้เราเก็บจำนวนของ $0$ จนถึงตำแหน่ง $k$ เพื่อใช้ในการคำนวณคำตอบ จากนี้ เราสามารถคำนวณจำนวนของ $1$ หลังตำแหน่ง $k$ ได้ด้วย ดังนั้นเราก็จะสามารถคำนวณคำตอบในแต่ละครั้งของการเปลี่ยนค่า $k$ ได้เร็ว ๆ  

time complexity ของวิธีนี้จะเท่ากับ $\mathcal{O}(n^2 \log n)$ จากการ sort ลำดับ $T$ ซึ่งมีความยาวเท่ากับ $m = n^2$
